
## Архитектура

Разработка архитектуры CSS-проекта, вероятно, одна из самых сложных задач, которую придётся сделать в жизни проекта. Сохранять архитектуру последовательной и значимой – ещё сложнее.

К счастью, одно из главных преимуществ использования CSS-препроцессоров – в возможности разделить кодовую базу на несколько файлов без ущерба для производительности (в отличие от CSS-правила `@import`). Благодаря `@import` в Sass, совершенно безопасно (и на самом деле рекомендуется) использовать столько файлов, сколько необходимо в разработке, все они потом будут собраны в одну таблицу стилей и так попадут на продакшен.

Кроме того, я не могу не подчеркнуть потребность в папках, даже на небольших проектах. Дома вы не кладёте каждый лист бумаги в один и тот же ящик. Вы используете папки; одну для дома, другую для банка, третью для счетов, и так далее. Нет причины поступать иначе при определении структуры CSS-проекта. Разделяйте кодовую базу на папки, чтобы позже легко было найти нужный код.

Существует [много популярных архитектур](https://www.sitepoint.com/look-different-sass-architectures/) для CSS проектов: [OOCSS](https://www.smashingmagazine.com/2011/12/12/an-introduction-to-object-oriented-css-oocss/), [Atomic Design](https://bradfrost.com/blog/post/atomic-web-design/), [Bootstrap](https://getbootstrap.com/), [Foundation](https://get.foundation/) и тому подобные… все они имеют свои достоинства, плюсы и минусы.

Я сам использую подход, который очень похож на [SMACSS](http://smacss.com/) от [Джонатана Снука](https://snook.ca/), который фокусируется на сохранении простоты и очевидности.

<div class="note">
  <p>Я осознал, что архитектура в основном зависит от проекта. Используйте или адаптируйте предложенное решение так, чтобы работать с системой, которая соответствует вашим потребностям.</p>
</div>

### Компоненты

Существует главное отличие между тем, чтобы сделать код *работающим*, или сделать его *хорошим*. Опять таки, CSS – довольно путаный язык <sup>[указать источник]</sup>. Чем меньше CSS, тем лучше. Мы не хотим иметь дело с мегабайтами кода. Чтобы держать файлы стилей короткими и эффективными – и это не будет для вас сюрпризом – чаще всего будет хорошей идеей подумать об интерфейсе, как о наборе компонентов.

Компоненты могут быть чем угодно, до тех пор, пока они:

* делают одну и только одну вещь;
* могут быть повторно используемы;
* независимы.

Например, форма поиска должна рассматриваться в качестве компонента. Она должна иметь возможность быть используемой повторно на разных страницах, в различных ситуациях. Она не должна зависеть от положения в DOM (в подвале, в боковой панели, в основном содержимом…).

Большинство интерфейсов можно рассматривать как набор маленьких компонентов, и я настоятельно рекомендую вам придерживаться этой парадигмы. Это позволит не только сократить количество CSS, необходимого для всего проекта, но также упростить его поддержку, и прибрать хаотический беспорядок.

### Структура компонента

В идеале, компоненты должны располагаться в своих собственных файлах (partial) (в папке `components/`, как описано в главе [7-1 pattern](#section-39)), например `components/_button.scss`. Стили, описываемые в каждом компоненте должны быть связаны только с:

* стилем самого компонента;
* стилем вариантом компонента, его модификаторами и состояниями;
* стили потомков компонента (то есть детей), если это необходимо.

Если вы хотите, чтобы ваши компоненты можно было стилизовать внешней темой (то есть темой внутри папки `themes/`), ограничьтесь объявлением только структурных стилей, такие как размеры (ширина/высота), паддинги, отступы, выравнивание и так далее. Исключитте такие стили как цвет, тени, настройки шрифта, фона и так далее.

В файл компонента можно включать специфичные для этого компонента переменные, плейсхолдеры и даже миксины и функции. Однако имейте в виду, что следует избегать зависимостей (то есть `@import`-а) от других компонентов, так как привратит ваш проект в мешанину неконтролируемых зависимостей, которые невозможно поддерживать.

Вот пример компонента кнопка:

{% include snippets/architecture/06/index.html %}

<div class="note">
  <p>Благодарю <a href="https://twitter.com/davidkpiano">David Khourshid</a> за помощь и экспертизу этой главы.</p>
</div>

### Шаблон 7-1

Возвратимся к архитектуре? Я обычно использую так называемый *Шаблон 7-1*: 7 папок, 1 файл. Обычно весь наш код можно распределить в 7 папок и один файл в корневом каталоге (обычно с именем `main.scss`), который импортирует их все.

* `base/`
* `components/`
* `layout/`
* `pages/`
* `themes/`
* `utils/`
* `vendors/`

И, конечно же:

* `main.scss`

<div class="note">
  <p>Если вы хотите использовать паттерн 7-1, вот готовый <a href="https://github.com/KittyGiraudel/sass-boilerplate">шаблон</a> на Гитхабе. В нём содержится всё что нужно для начала работы по этой архитектуре.</p>
</div>

{% include images/wallpaper.html %}

В идеале, в конечном итоге у нас получится что-то такое:

{% include snippets/architecture/01/index.html %}

<div class="note">
  <p>Файлы с тем же соглашением по именованию, что и выше, начинаются с нижнего подчеркивания.</p>
</div>

#### Папка Base

Папка `base/` содержит то, что мы можем назвать общим шаблоном проекта. Там вы можете найти файл сброса, некоторые типографские правила, и, вероятно, стили (я привык их называть `_base.scss`), определяющие некоторые стандартные стили для часто используемых элементов HTML.

* `_base.scss`
* `_reset.scss`
* `_typography.scss`

<div class="note">
  <p>Если в проекте <em>много</em> CSS анимации, то, возможно, стоит добавить файл <code>\_animations.scss</code>, который будет содержать определения <code>@keyframes</code> всех анимаций. Если же в проекте всего пара таких штук, оставьте их рядом с селекторами, использующие их.</p>
</div>

#### Папка Layout

Папка `layout/` содержит всё, что принимает участие в постройке раскладки сайта или приложения. Эта папка может содержать стили для основных частей сайта (шапка, подвал, навигация, боковая панель…), сетка или даже CSS-стили для всех форм.

* `_grid.scss`
* `_header.scss`
* `_footer.scss`
* `_sidebar.scss`
* `_forms.scss`
* `_navigation.scss`

<div class="note">
  <p>Папка <code>layout/</code> может быть названа <code>partials/</code>, на ваше усмотрение.</p>
</div>

#### Папка Components

Для маленьких компонентов существует папка `components/`. В то время, как `layout/` –  *основные* (определяют общий каркас), код внутри `components/` больше сфокусирован на виджетах и содержит все модули, вроде слайдера, загрузчика и тому подобных виджетов. Обычно файлов в `components/` много, если приложение или сайт состоит из множества мелких модулей.

* `_media.scss`
* `_carousel.scss`
* `_thumbnails.scss`

<div class="note">
  <p>Папка <code>components/</code> может называться <code>modules/</code>, на ваше усмотрение.</p>
</div>

#### Папка Pages

Если у вас есть стили, зависящие от страницы, лучше положить их в папку `pages/`, в файл, названный как и страница. Например, не редкость – иметь очень специфичные стили для главной страницы, следовательно, существует потребность в `_home.scss` в `pages/`.

* `_home.scss`
* `_contact.scss`

<div class="note">
  <p>В зависимости от способа деплоя, эти файлы можно назвать по-своему, чтобы избежать их объединения с другими стилями. На ваше усмотрение.</p>
</div>

#### Папка Themes

В больших сайтах и приложениях не редко имеются различные темы оформления. Есть разные способы работы с темами, я лично предпочитаю складывать их в папку `themes/`.

* `_theme.scss`
* `_admin.scss`

<div class="note">
  <p>Это очень зависит от проекта и не сильно распространено.</p>
</div>

#### Папка Abstracts

Папка `abstracts/` собирает все инструменты и хелперы Sass в проекте. Каждая глобальная переменная, функция и примесь должна быть помещена сюда.

Правило для этой папки в том, что она не должна создавать CSS при компиляции сама по себе. Это не что иное, как Sass хелперы.

* `_variables.scss`
* `_mixins.scss`
* `_functions.scss`
* `_placeholders.scss` (часто называется `_helpers.scss`)

При работе над очень большим проектом с большим количеством абстракций, возможно, стоит их группировать по темам, а не по типу. Например, типографику (`_typography.scss`), темы оформления (`_theming.scss`), и так далее. Каждый файл содержит все относящиеся к нему хелперы: переменные, функции, миксины и плейсхолдеры. Это сильно облегчит понимание и обслуживание кода, особенно когда файлы становятся очень длинными.

<div class="note">
  <p>Папка <code>abstracts/</code> может также быть названа <code>utilities/</code> или <code>helpers/</code>, на ваше усмотрение.</p>
</div>

#### Папка Vendors

И последнее, но не менее важное, большинство проектов будут иметь папку `vendors/`, содержащую все CSS-файлы из внешних библиотек и фреймворков – Normalize, Bootstrap, jQueryUI, FancyCarouselSliderjQueryPowered и так далее. Нахождение этих файлов в этой папке – хороший способ сказать: "Эй, это не я писал, не мой код, не моя ответственность".

* `_normalize.scss`
* `_bootstrap.scss`
* `_jquery-ui.scss`
* `_select2.scss`

Если вы хотите что-то переопределить в файлах любого вендора, то я рекомендую вам ввести восьмую папку `vendors-extensions/`, в которой вы будете хранить файлы с точно такими же именами, что и файлы, которые они переопределяют.

Например, файл `vendors-extensions/_boostrap.scss`, содержит все CSS-правила, переопределящие стандартные CSS-правила Bootstrap. Это сделано для того, чтобы не править сами внешние модули, что является совсем не здоровской идеей.

#### Файл Main

Главный файл (обычно называемый `main.scss`) должен быть единственным файлом Sass, который не начинается с нижнего подчеркивания. Этот файл не должен содержать ничего, кроме `@import` и комментариев.

Файлы должны быть импортированы в соответствии с папками размещения, один за другим, в следующем порядке:

1. `abstracts/`
1. `vendors/`
1. `base/`
1. `layout/`
1. `components/`
1. `pages/`
1. `themes/`

Чтобы улучшить читаемость, главный файл должен следовать этим рекомендациям:

* один файл на один `@import`;
* один `@import` на строку;
* не вставлять пустую строку между файлами из одной папки;
* вставлять пустую строку после последнего импорта из папки;
* не писать расширения файлов и нижние подчеркивания.

{% include snippets/architecture/02/index.html %}

Существует ещё один способ импорта, который я считаю допустимым. С одной стороны, файл становится более читаемым. С другой стороны, его обновление становится немного более болезненным. Во всяком случае, вам решать, что лучше, это не имеет большого значения. Основной файл следует следующим принципам:

* один `@import` на папку;
* разрыв строки после `@import`;
* каждый файл на отдельной строке;
* пустая строка после последнего импорта файла из папки;
* не писать расширения файлов и нижние подчеркивания.

{% include snippets/architecture/03/index.html %}

### О глобинге

В программировании, глоб шаблоны определяют набор файлов через символы подстановки, такие как `*.scss`. В общем, глоббинг означает определение набора файлов на основе выражения вместо списка имен файлов. Применимо к Sass, это означает импортирование составных файлов в основной файл [main file](#main) с глоб шаблоном, а не перечислением их по отдельности. Таким образом, основной файл будет выглядеть так:

{% include snippets/architecture/05/index.html %}

Sass не поддерживает глоббинг из коробки, потому что он может привести к опасным последствиям, так как в CSS имеет значение порядок определения правил. При динамическом импорте правил (обычно в алфавитном порядке) отсутствует контроль над порядком импорта файлов, что может привести к трудноотлавливаемым побочным эффектам.

Как было сказано ранее, в строгой компонентно-основаной архитектуре с особым контролем за перетеканием стилей от одного компонента к другому, порядок импорта не особо важен, и в таком случае, использование глоб-импорта допустимо. Тогда становится легче добавлять и удалять компоненты, а обновлять главный файл при этом не требуется.

При использовании Ruby Sass, есть Ruby гем, который называется [sass-globbing](https://github.com/chriseppstein/sass-globbing) который включает именно эту возможность. Если разработка на node-sass, остаётся полагаться либо на Node.js, либо на любой сборщик, который позаботится о подобной сборке (Gulp, Grunt и т.д.).

### Файл позора

Это интересная идея, которая стала популярна благодаря [Гарри Робертсу](https://csswizardry.com), [Дэйву Руперту](https://daverupert.com) и [Крису Койеру](https://css-tricks.com) и состоит в том, чтобы складывать все хаки и код, которым вы не гордитесь, в *файл позора*. Поэтому этот файл и имеет такое драматическое название – `_shame.scss`, и импортируется в самом конце.

{% include snippets/architecture/04/index.html %}
