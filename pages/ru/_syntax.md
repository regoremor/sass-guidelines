
## Синтаксис и форматирование

Если вы спросите меня, что таблица стилей должна делать в первую очередь – так это показать, как мы хотим преподнести наш код.

Когда несколько разработчиков участвуют в написании CSS проекта(ов), то лишь вопрос времени, когда один из них начнёт делать вещи по-своему. Руководство стилей способствуют не только в согласованности, но и помогает, когда приходит время читать и обновлять код.

Грубо говоря, мы хотим (бесстыдно вдохновлён [CSS Guidelines](https://cssguidelin.es/#syntax-and-formatting)):

* двойные (2) отступы пробелом, никаких табов;
* в идеале, 80-символьную ширину строк;
* правильно написанные многострочные CSS правила;
* осмысленное использование пробелов.

{% include snippets/syntax/01/index.html %}

### Строки

Поверите ли, но строки играют весьма важную роль и в CSS и в Sass экосистемах. Большинство CSS значений — либо длины либо идентификаторы, так что на самом деле очень важно придерживаться некоторых рекомендаций при работе со строками в Sass.

#### Кодировка

Чтобы избежать потенциальных проблем с кодировкой символов, крайне рекомендуется использовать кодировку [UTF-8](https://ru.wikipedia.org/wiki/UTF-8) в [основной таблице стилей](#main), используя директиву `@charset`. Убедитесь, что она идёт первой строкой в таблице стилей и перед ней ничего нет.

{% include snippets/syntax/02/index.html %}

#### Кавычки

CSS не требует, чтобы строки были помещены в кавычки, даже те, что содержат пробелы. Возьмите названия семейства шрифтов, например: не имеет значения, оборачиваете ли вы их в кавычки для CSS-парсера или нет.

Из-за этого, Sass *также* не требует помещения строк в кавычки. Более того (и, *к счастью,* согласитесь), строка в кавычках является точным соответствием её двойника без кавычек (например, строка `'abc'` строго равна `abc`).

Языки, которые не требуют, чтобы строки были в кавычках, определенно, в меньшинстве, так что **строки должны всегда быть обёрнуты в одинарные кавычки** в Sass (одну проще набрать, чем двойную, на *QWERTY*-клавиатуре). Кроме того, для согласованности с другими языками, в том числе с двоюродным братом CSS – JavaScript’ом, есть несколько причин для такого выбора:

* названия цветов рассматриваются как цвета, когда без кавычек, что может привести к серьёзным проблемам;
* большинство синтаксических анализаторов будут в шоке от строк без кавычек;
* это помогает общей читаемости;
* нет обоснованной причины не оборачивать строки в кавычки.

{% include snippets/syntax/03/index.html %}

<div class="note">
  <p>Как указано в спецификации CSS, директива <code>@charset</code> должна быть объявлена в двойных кавычках <a href="https://www.w3.org/TR/css3-syntax/#charset-rule">чтобы считаться валидной</a>. Однако, Sass позаботится об этом во время компилирования, так что финальный результат будет всегда правильный. Можете спокойно использовать одинарные кавычки даже для <code>@charset</code>.</p>
</div>

#### Строки как значения CSS

Специальные значения CSS (идентификаторы), такие как `initial` или `sans-serif` требует не быть закавыченными. В самом деле, объявление `font-family: 'sans-serif'` потерпит неудачу, потому что CSS ожидает идентификатор, а не строку с кавычками. Именно поэтому, мы не оборачиваем в кавычки эти значения.

{% include snippets/syntax/04/index.html %}

Следовательно, можно провести различие между строками, которые должны использоваться как значения CSS (идентификаторы CSS), как в предыдущем примере, и строками, которые привязаны к типу данных Sass, например, к ключам мапы.

Первое без кавычек, а второе в одинарных кавычках.

#### Строки, содержащие кавычки

Если строка содержит одну или несколько одинарных кавычек, можно воспользоваться оборачиванием строки в двойный кавычки (`"`), чтобы избежать применение эскейп-последовательностей в строке.

{% include snippets/syntax/05/index.html %}

#### УРЛы

URL тоже должны быть в кавычках, по тем же причинам, что и выше:

{% include snippets/syntax/06/index.html %}

### Числа

В Sass число – это тип данных, включая всё, от безразмерных чисел до длин, длительности, частоты, углов и так далее. Это позволяет проводить на них расчёты.

#### Нули

В десятичных положительных значениях чисел меньше единицы следует ставить нуль перед точкой. Никогда не ставить незначащие нули после точки.

{% include snippets/syntax/07/index.html %}

<div class="note">
  <p>В Sublime Text и других редакторах с поддержкой поиска и замены регулярными выражениями очень легко добавить незначащий нуль в начало (большинства, если не всех) чисел с плавающей точкой. Просто замените <code>\s+\.(\d+)</code> на <code>\ 0.$1</code>. Обратите внимание на пробел перед <code>0</code>.</p>
</div>

#### Единицы измерения

При работе с длинами, `0` (нуль) никогда не должен иметь единицу измерения.

{% include snippets/syntax/08/index.html %}

<div class="note">
  <p>Внимательно, эта практика относится только к длинам. Нуль без единиц измерения для свойств времени, таких как <code>transition-delay</code> не допускается. Теоретически, если нуль без единиц измерения указан для продолжительности, это объявление признаётся недействительным и отбрасывается. Не все браузеры столько строги, но некоторые да. Короче говоря: опускать единицу измерения только для длин.</p>
</div>

Самая распространённая ошибка о числах в Sass, которую можно только представить – это думать, что единицы измерения – всего лишь строки, которые можно запросто прилагать к числу. Хотя это и звучит как правда, но единицы измерения работают совсем не так. Думайте о единицах измерения в контексте алгебраических символов. Например, в реальном мире, умножение 5 дюймов на 5 дюймов даст вам 25 квадратных дюймов. Та же логика применима и к Sass.

Чтобы добавить единицу измерения в число, нужно умножить это число на *1 единицу измерения*.

{% include snippets/syntax/09/index.html %}

Заметим, что прибавление *0 единиц этого значения* также работает, но я скорее бы порекомендовал вышеупомянутый метод умножения, так как прибавление *0 единиц измерения* может быть немного запутанным. Действительно, при попытке преобразовать число в другую единицу измерения, прибавление нуля не провернёт этот трюк. Подробнее [в этой статье](https://css-tricks.com/snippets/sass/correctly-adding-unit-number/).

{% include snippets/syntax/10/index.html %}

В конце концов, всё зависит от того, чего вы пытаетесь достичь. Просто имейте в виду, что добавление единицы измерения как строки – не лучшее решение.

Чтобы убрать единицу измерения из значения, нужно разделить его на *одну единицу этой же меры*.

{% include snippets/syntax/11/index.html %}

Добавляя единицу измерения как строку в число превращает всё в строку, препятствуя любым дополнительным операциям над значением. Разделение числа и единицы измерения тоже возвращает строку. Это не то, чего вы хотите. [Используйте длины, не строки](https://kittygiraudel.com/2013/09/03/use-lengths-not-strings/).

#### Вычисления

**Числовые рассчёты должны всегда быть в круглых скобках**. Мало того, что это требование значительно улучшает читаемость, оно также предотвращает некоторые крайние случаи, заставляя Sass считать содержимое скобок.

{% include snippets/syntax/12/index.html %}

#### Магические числа

"Магическое число" - это [термин старой школы программирования](https://ru.wikipedia.org/wiki/Магическое_число_(программирование)#Unnamed_numerical_constants) для *неименованных числовых констант*. В принципе, это просто случайное число, которое *просто работает*™ и ещё не привязано к какому-либо логическому объяснению.

Излишне говорить, **магические числа — чума, и их следует избегать любой ценой**. Если вы не можете найти разумное объяснение тому, почему число работает, добавьте обширный комментарий, объясняющий, как вы туда попали и почему вы думаете, что это работает. Признание в том, что вы не знаете, почему что-то работает, будет еще более полезным для следующего разработчика, чем исследования происходящего на пустом месте.

{% include snippets/syntax/13/index.html %}

По теме у CSS-Tricks есть [потрясающая статья](https://css-tricks.com/magic-numbers-in-css/) о магических числах в CSS, которую я призываю вас прочитать.

### Цвета

Цвета занимают важное место в языке CSS. Естественно, Sass является ценным союзником, когда дело доходит до управления цветами, в основном – путём предоставления [мощных функций](https://sass-lang.com/documentation/Sass/Script/Functions.html).

Sass настолько полезен, когда приходится манипулировать цветами, что интернет прямо зацвёл от обилия статей на эту тему. Позвольте порекомендовать несколько хороших:

* [How to Programmatically Go From One Color to Another](https://kittygiraudel.com/2014/01/30/programmatically-go-from-one-color-to-another-with-sass/)
* [Using Sass to Build Color Palettes](https://www.sitepoint.com/using-sass-build-color-palettes/)
* [Dealing with Color Schemes in Sass](https://www.sitepoint.com/dealing-color-schemes-sass/)

#### Цветовые форматы

Для того, чтобы сделать цвета простыми, насколько возможно, советую соблюдать следующий порядок предпочтения цветовых форматов:

1. [Обозначение HSL](https://en.wikipedia.org/wiki/HSL_and_HSV);
1. [Обозначение RGB](https://en.wikipedia.org/wiki/RGB_color_model);
1. Шестнадцатеричная нотация. Предпочтительно в нижнем регистре и по возможности укороченная.

Названия стандартных цветов CSS не следует использовать, разве что для быстрого прототипирования. Именно так, это английские слова и некоторые из них сослужат плохую службу для описания цвета, который они означают, особенно для тех, кому английский не родной язык. Кроме того, эти названия не очень-то сематичны; например  `grey` в действительности темнее, чем `darkgrey`, и путаница между `grey` и `gray` может привести к мешанине при использовании этого цвета.

Представление HSL – не только самое простое для человеческого мозга <sup>[указать источник]</sup>, но у него и самый лёгкий способ настройки цвета путём регулировки цветового тона, насыщенности и яркости индивидуально. 

RGB по-прежнему имеет преимущество, показывая прямо сейчас, что цвет более синий, зелёный или красный. Таким образом, этот способ может в некоторых случаях быть удачным, особенно при описании чистых красных, зеленых и синих цветов. Но это не делает его лёгким в построении цвета из трёх частей.

Наконец, шестнадцатеричное представление слишком сложно для расшифровки человеческим умом. Используйте его только в случае крайней необходимости.

{% include snippets/syntax/14/index.html %}

При использовании обозначений HSL или RGB, всегда пишите один пробел после запятой (`,`) и не ставьте пробел между скобками (`(`, `)`) и содержимым.

{% include snippets/syntax/15/index.html %}

#### Цвета и переменные

При использовании цвета более одного раза, сохраняйте его в переменной с осмысленным названием, описывающим цвет.

{% include snippets/syntax/16/index.html %}

Теперь вы можете использовать эту переменную, когда захотите. Однако, если ваше использование сильно привязано к теме, я бы не советовал использовать переменные как есть. Вместо этого, храните их в других переменных с именем, объясняющим, как она должна быть использована.

{% include snippets/syntax/17/index.html %}

Так вы воспрепятствуете изменениям темы, ведущим к чему-то вроде `$sass-pink: blue`. [Эта статья](https://davidwalsh.name/sass-color-variables-dont-suck) здорово объясняет, почему важно учитывать ваши цветовые переменные.

#### Осветление и затемнение цветов

Обе функции [`lighten`](https://sass-lang.com/documentation/Sass/Script/Functions.html#lighten-instance_method) и [`darken`](https://sass-lang.com/documentation/Sass/Script/functions.html#darken-instance_method) манипулируют цветами пространства HSL, добавляя или вычитая в пространстве HSL. В принципе, они ни что иное, как алиасы для параметра `$lightness` в функции [`adjust-color`](https://sass-lang.com/documentation/Sass/Script/Functions.html#adjust_color-instance_method).

Дело в том, что эта функция часто не даёт ожидаемого результата. С другой стороны, функция [`mix`](https://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method) является хорошим способом осветлить или затемнить цвет, смешивая его либо с `white`, либо с ` black`.

Преимуществом использования `mix` перед одной из двух указанных функций выше является то, что она будет постепенно меняться на чёрный (или белый), когда вы уменьшаете долю цвета, в то время как `darken` и `lighten` быстро меняют цвет на чёрный или белый.

{% include images/color-functions.html %}

Если вы не хотите писать функцию `mix` каждый раз, вы можете создать две простых в использовании функции `tint` и `shade` (которые также являются частью [Compass](http://compass-style.org/reference/compass/helpers/colors/#shade)), чтобы сделать то же самое:

{% include snippets/syntax/18/index.html %}

<div class="note">
  <p>Функция <a href="https://sass-lang.com/documentation/Sass/Script/Functions.html#scale_color-instance_method"><code>scale-color</code></a> разработана, чтобы изменять свойства более плавно, принимая во внимание, насколько они уже изменены. Результат так же хорош, как и от <code>mix</code>, но с более удобным вызовом. Хотя, множитель масштабирования – не совсем то же самое.</p>
</div>

### Списки

Списки Sass эквиваленты массивам. Список представляет собой плоскую структуру данных (в отличие от [карт](#section-25)), предназначенную для хранения значений любого типа (в том числе списков со вложенными списками).

Списки должны соблюдать следующие правила:

* либо в одну строку, либо многострочный;
* многострочный необходим, если не помещается в 80-символьную строку;
* если используется для целей CSS, всегда разделяется запятой;
* всегда оборачивается круглыми скобками;
* в многострочном списке ставится запятая после последнего элемента.

{% include snippets/syntax/19/index.html %}

При добавлении новых записей в список, всегда используйте прилагаемый API. Не пытайтесь добавлять новые элементы вручную.

{% include snippets/syntax/20/index.html %}

В [этой статье](https://kittygiraudel.com/2013/07/15/understanding-sass-lists/), я привожу множество советов и хитростей, как правильно обрабатывать и управлять списками в Sass.

### Карты

С помощью Sass, авторы таблиц стилей могут создавать карты (maps) – термин Sass для связных массивов, хэшей или даже объектов JavaScript. Карта – это структура данных, сопоставляющая ключи со значениями. И ключ и значение может быть любым типом данных, включая карты, хотя я это не рекомендую использовать сложные типы данных как ключи карты, просто во имя здравого смысла.

Код карт следует писать следующим образом:

* пробел после двоеточия (`:`);
* открывающая скобка (`(`) на той же строке, что и двоеточие (`:`);
* **ключи в кавычках**, если это строки (а это так в 99% случаев);
* каждая пара ключ/значение на своей строке;
* запятая (`,`) на конце каждой пары ключ/значение;
* **закрывающая запятая** (`,`) на последней паре, чтобы легче добавлять, удалять или переставлять пункты;
* закрывающая скобка (`)`) на своей новой строке;
* без пробела или новой строки между закрывающей скобкой (`)`) и точкой с запятой (`;`).

Пример:

{% include snippets/syntax/21/index.html %}

Записей о картах Sass не столь много, сколь ожидаема была эта возможность. Вот три статьи, которые я рекомендую: [Using Sass Maps](https://www.sitepoint.com/using-sass-maps/), [Extra Map functions in Sass](https://www.sitepoint.com/extra-map-functions-sass/), [Real Sass, Real Maps](http://blog.grayghostvisuals.com/sass/real-sass-real-maps/).

### Набор правил CSS

На данный момент, это, в основном, пересмотр того, что все и так знают, но вот как набор правил CSS должен быть написан (по крайней мере, по мнению большинства руководств, в том числе [CSS Guidelines](https://cssguidelin.es/#anatomy-of-a-ruleset)):

* связанные селекторы на одной строке; не связанные селекторы на новой строке;
* открывающая скобка (`{`) отделяется от последнего селектора одним пробелом;
* каждое объявление на собственной новой строке;
* пробел после двоеточия (`:`);
* завершающая точка с запятой (`;`) в конце всех объявлений;
* закрывающая скобка (`}`) на своей новой строке;
* новая строка после закрывающей скобки `}`.

Пример:

{% include snippets/syntax/24/index.html %}

Дополняя те руководства по CSS, мы должны обратить внимание на:

* локальные переменные объявляются перед любыми объявлениями, потом отделяются от деклараций новой строкой;
* вызовы примесей без `@content` идут перед любым объявлением;
* вложенные селекторы всегда идут после новой строки;
* вызовы примесей с `@content` идут после вложенных селекторов;
* без новых строк перед закрывающей фигурной скобкой (`}`).

Пример:

{% include snippets/syntax/25/index.html %}

### Порядок объявлений

Невозможно удержать в голове все обсуждения, где мнения о сортировке объявлений в CSS настолько разнятся. Вообще, можно выявить два лагеря:

* придерживаться алфавитного порядка;
* упорядочивание по назначению (position, display, colors, font, miscellaneous…).

Есть плюсы и минусы в обоих вариантах. С одной стороны, сортировка в алфавитном порядке является универсальной (по крайней мере, для языков, использующих латинский алфавит), поэтому нет никаких споров о сортировке свойств. Тем не менее, мне весьма странно видеть свойства, такие как `bottom` и `top`, не рядом друг с другом. Почему анимации должны быть перед `display`? Есть много странностей с алфавитным упорядочиванием.

{% include snippets/syntax/26/index.html %}

С другой стороны, сортировка свойств по типу имеет смысл. Каждые объявления, относящиеся к шрифтам, располагаются рядом, как `top` и `bottom`, и чтение набора правил отчасти становится похожим на чтение рассказа. Но пока вы строго не придерживаетесь определённых соглашений, типа [Idiomatic CSS](https://github.com/necolas/idiomatic-css), существует много спорных моментов. Где будет `white-space` – рядом со шрифтами или с `display`? Где расположить `overflow`? Что такое порядок свойств в группе (может быть в алфавитном порядке, о ирония)?

{% include snippets/syntax/27/index.html %}

Существует также ещё одно интересное поддерево способа упорядочивания, называется [Concentric CSS](https://github.com/brandon-rhodes/Concentric-CSS), и, кажется, оно довольно популярно. В своей основе, Concentric CSS опирается на блочную модель, чтобы определить порядок: начинается за пределами, движется внутрь.

{% include snippets/syntax/28/index.html %}

Должен сказать, я сам не могу определиться. [Недавний опрос на CSS-Tricks](https://css-tricks.com/poll-results-how-do-you-order-your-css-properties/) установил, что более 45% разработчиков упорядочивают свойства по их назначению, против 14% в алфавитном порядке. Кроме того, 39% об этом вообще не думают, и я в том числе.

{% include images/order-poll.html %}

Поэтому я не буду навязывать вам выбор. Выберите способ, какой вам больше нравится (кроме варианта *случайным образом*) и следуйте ему в ваших таблицах стилей.

<div class="note">
  <p><a href="https://web.archive.org/web/20190618180712/http://peteschuster.com/2014/12/reduce-file-size-css-sorting/">Недавние исследования</a> показали, что использование <a href="https://github.com/csscomb/csscomb.js">CSS Comb</a> (которое использует <a href="https://github.com/csscomb/csscomb.js/blob/master/config/csscomb.json">упорядочивание по типу</a>) помогает уменьшить общий размер файла на 2.7% при сжатии Gzip, в сравнении с 1.3%, когда происходит упорядочение по алфавиту.</p>
</div>

### Вложенность селекторов

Одна особенность Sass, которую не слишком используют многие разработчики – *вложенность селекторов*. Она позволяет автору таблицы стилей вычислять длинные селекторы, вкладывая короткие селекторы друг в друга.

#### Общие правила

Например, такая вложенность Sass:

{% include snippets/syntax/29/index.html %}

…создаст такой CSS:

{% include snippets/syntax/30/index.html %}

Начиная с Sass 3.3 можно использовать ссылку на текущий селектор, используя `&`, чтобы создать дополнительные селекторы. Например:

{% include snippets/syntax/31/index.html %}

…сгенерирует такой CSS:

{% include snippets/syntax/32/index.html %}

Этот метод часто используется в [методологии BEM](https://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/) для генерации селекторов `.block__element` и `.block--modifier`, основанных на базовом селекторе (т.е. `.block` в данном примере).

<div class="note">
  <p>Выходит анекдотично, что создание новых селекторов из ссылки на текущий селектор (<code>&</code>) делает новые селекторы недоступными для поиска в кодовой базе, так как они не существуют как таковые.</p>
</div>

Проблема с вложенностью селекторов в том, что это в конечном итоге делает код более трудным для чтения. Нужно уметь мысленно вычислять, что получится в результате из уровней вложенности; не всегда вполне очевидно, что за CSS будет в конечном итоге.

Это утверждение становится правдивее, когда селекторы становятся длиннее и ссылки на текущий селектор (`&`) более частыми. В какой-то момент риск потерять след и не суметь понять, что происходит, становится настолько высок, что не стоит того.

Для предотвращения таких ситуаций, мы много говорили о [правиле Начала](https://thesassway.herokuapp.com/beginner/the-inception-rule) несколько лет назад. Оно советует избегать вложенности более трёх уровней, отсылая к сюжету фильма «Начало» Кристофера Нолана. Я буду более резок и рекомендую **избегайте вложенности селекторов, насколько это возможно**. 

Тем не менее, есть, очевидно, несколько исключений из этого правила, и как мы увидим в следующем разделе, это мнение кажется довольно популярным. Вы можете прочитать об этом детальнее в статьях [Beware of Selector Nesting](https://www.sitepoint.com/beware-selector-nesting-sass/) и [Avoid nested selectors for more modular CSS](https://thesassway.herokuapp.com/intermediate/avoid-nested-selectors-for-more-modular-css).

#### Исключения

Для начала, допускается, и я даже рекомендую, вкладывать псевдоклассы и псевдоэлементы в родительский селектор.

{% include snippets/syntax/33/index.html %}

Использование вложенности селекторов для псевдоклассов и псевдоэлементов не только имеет смысл (потому что имеет дело с тесно связанными селекторами), но также помогает держать всю информацию о компоненте в одном месте.

Кроме того, при использовании классов, обозначающих состояние, таких как `.is-active`, это прекрасно подходит для того, чтобы вкладывать их под селектор компонента, чтобы всё выглядело аккуратно.

{% include snippets/syntax/34/index.html %}

Последнее, но не менее важное – при оформлении элемента часто случается, что он содержится в другом элементе, и тут также хорошо использовать вложенность, чтобы держать всё о компоненте в том же месте.

{% include snippets/syntax/35/index.html %}

Как и везде, специфика несколько неуместна, постоянство является ключевым фактором. Если вы чувствуете, что полностью уверены во вложенности селекторов, тогда используйте ее. Просто убедитесь, что вся ваша команда справится с этим.
